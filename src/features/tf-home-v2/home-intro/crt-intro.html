<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CRT Intro</title>
    <meta name="color-scheme" content="dark light" />
    <style>
      :root {
        --logo-max-width: min(42vw, 320px);
        --overlay-bg: #000;
        --flash-color: #ffffff;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: #0b0b0b;
        color: #e8e8e8;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji';
        overflow: hidden; /* prevent scroll jump during intro */
      }

      /* Demo site content (under the overlay) */
      main {
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 8vmin 4vmin;
      }

      /* Immediately visible logo (on top of overlay initially) */
      #intro-logo {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: var(--logo-max-width);
        height: auto;
        z-index: 3; /* above overlay */
        will-change: opacity, filter;
      }

      /* Fullscreen overlay with SVG mask/flash */
      #crt-overlay {
        position: fixed;
        inset: 0;
        background: var(--overlay-bg);
        z-index: 2; /* below intro logo, above content */
        display: block;
        opacity: 1;
        pointer-events: auto; /* blocks interaction until fade-out */
      }

      #crt-svg {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          animation: none !important;
          transition: none !important;
        }
      }

      /* Developer control panel */
      #crt-ui {
        position: fixed;
        right: 12px;
        top: 12px;
        z-index: 5; /* above overlay and logo */
        background: rgba(10, 10, 10, 0.9);
        color: #eaeaea;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 8px;
        padding: 10px 12px;
        font-size: 12px;
        line-height: 1.35;
        width: min(90vw, 300px);
        backdrop-filter: blur(4px);
      }
      #crt-ui h2 {
        margin: 0 0 8px 0;
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.02em;
        text-transform: uppercase;
      }
      #crt-ui .row {
        display: grid;
        grid-template-columns: 1fr 72px;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }
      #crt-ui label {
        opacity: 0.85;
      }
      #crt-ui input[type='number'] {
        width: 100%;
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.06);
        color: #fff;
      }
      #crt-ui .actions {
        display: flex;
        gap: 8px;
      }
      #crt-ui button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.06);
        color: #fff;
        padding: 6px 10px;
        border-radius: 6px;
        cursor: pointer;
      }
      #crt-ui details {
        margin-top: 6px;
        opacity: 0.85;
      }
    </style>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"
      defer
    ></script>
  </head>
  <body>
    <!-- The logo will be detected from the page (#tf-logo-intro or .tf-logo-intro),
         cloned as a temporary fixed overlay (#intro-logo) for blending, and then removed. -->

    <!-- Fullscreen overlay hosting the CRT reveal and glow -->
    <div id="crt-overlay" aria-hidden="true">
      <svg
        id="crt-svg"
        xmlns="http://www.w3.org/2000/svg"
        preserveAspectRatio="none"
      >
        <defs>
          <!-- Glow filter -->
          <filter id="crtGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur
              in="SourceGraphic"
              stdDeviation="12"
              result="blur1"
            />
            <feGaussianBlur
              in="SourceGraphic"
              stdDeviation="24"
              result="blur2"
            />
            <feMerge>
              <feMergeNode in="blur2" />
              <feMergeNode in="blur1" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>

          <!-- Mask that reveals content by growing an ellipse from center -->
          <mask id="revealMask" maskUnits="userSpaceOnUse">
            <rect
              id="mask-bg"
              x="0"
              y="0"
              width="100%"
              height="100%"
              fill="black"
            />
            <ellipse
              id="mask-ellipse"
              cx="0"
              cy="0"
              rx="2"
              ry="2"
              fill="white"
            />
          </mask>
        </defs>

        <!-- Solid black background that hides the page until the mask reveals it -->
        <rect
          id="overlay-bg"
          x="0"
          y="0"
          width="100%"
          height="100%"
          fill="#000000"
        />

        <!-- The bright flash that grows; clipped by the mask ellipse -->
        <g mask="url(#revealMask)">
          <rect
            id="flash-white"
            x="0"
            y="0"
            width="100%"
            height="100%"
            fill="var(--flash-color)"
            opacity="0.9"
          />
          <rect
            id="flash-glow"
            x="0"
            y="0"
            width="100%"
            height="100%"
            fill="var(--flash-color)"
            opacity="0.45"
            filter="url(#crtGlow)"
          />
        </g>
      </svg>
    </div>

    <!-- Demo content beneath -->
    <main>
      <h1>Site content</h1>
      <p>This content becomes interactable after the intro fades.</p>
    </main>

    <script>
      ;(function () {
        // ---- Runtime parameters (ms/px) ----
        const DEFAULT_PARAMS = {
          dotDuration: 120,
          squishDuration: 160,
          lineHoldDuration: 0, // Explicitly 0 for no pause
          horizontalDuration: 260,
          verticalDuration: 111,
          finalPaddingPx: 0,
          anticipationStretchPx: 6,
          anticipationDuration: 140,
          anticipationRecoilDuration: 120,
          glowStrength: 1.0,
          minRy: 1,
          flashOpacity: 0.9,
          glowOpacity: 0.45,
          easing: 'easeOutQuad', // Snappier end for seamless handoff
          easeIntensity: 0.8,
        }

        function clamp(value, min, max) {
          if (value < min) return min
          if (value > max) return max
          return value
        }

        function setupSvgSizing() {
          const svg = document.getElementById('crt-svg')
          const vw = Math.max(
            document.documentElement.clientWidth || 0,
            window.innerWidth || 0
          )
          const vh = Math.max(
            document.documentElement.clientHeight || 0,
            window.innerHeight || 0
          )
          svg.setAttribute('viewBox', `0 0 ${vw} ${vh}`)
          return { vw, vh }
        }

        function readParams() {
          try {
            const raw = localStorage.getItem('crtIntroParams')
            if (!raw) return { ...DEFAULT_PARAMS }
            const parsed = JSON.parse(raw)
            return { ...DEFAULT_PARAMS, ...parsed }
          } catch (e) {
            return { ...DEFAULT_PARAMS }
          }
        }

        function saveParams(params) {
          try {
            localStorage.setItem('crtIntroParams', JSON.stringify(params))
          } catch (e) {}
        }

        function ensureUi(params) {
          if (document.getElementById('crt-ui')) return params
          const panel = document.createElement('div')
          panel.id = 'crt-ui'
          panel.innerHTML = `
            <h2>CRT Intro</h2>
            <div class="row"><label>Initial dot (ms)</label><input id="p-dot" type="number" min="10" max="2000" step="10" value="${
              params.dotDuration
            }"></div>
            <div class="row"><label>Squish duration (ms)</label><input id="p-squish" type="number" min="10" max="2000" step="10" value="${
              params.squishDuration
            }"></div>
            <div class="row"><label>Line hold (ms)</label><input id="p-hold" type="number" min="0" max="1500" step="10" value="${
              params.lineHoldDuration
            }"></div>
            <div class="row"><label>Anticipation stretch (px)</label><input id="p-antpx" type="number" min="0" max="200" step="1" value="${
              params.anticipationStretchPx
            }"></div>
            <div class="row"><label>Anticipation duration (ms)</label><input id="p-antms" type="number" min="0" max="2000" step="10" value="${
              params.anticipationDuration
            }"></div>
            <div class="row"><label>Anticipation recoil (ms)</label><input id="p-recoilms" type="number" min="0" max="2000" step="10" value="${
              params.anticipationRecoilDuration
            }"></div>
            <div class="row"><label>Horizontal expand (ms)</label><input id="p-horiz" type="number" min="10" max="4000" step="10" value="${
              params.horizontalDuration
            }"></div>
            <div class="row"><label>Vertical expand (ms)</label><input id="p-vert" type="number" min="10" max="4000" step="10" value="${
              params.verticalDuration
            }"></div>
            <div class="row"><label>Final padding (px)</label><input id="p-pad" type="number" min="0" max="1000" step="2" value="${
              params.finalPaddingPx
            }"></div>
            <div class="row"><label>Glow strength (Ã—)</label><input id="p-glow" type="number" min="0" max="3" step="0.1" value="${
              params.glowStrength
            }"></div>
            <div class="row"><label>Line thinness ry (px)</label><input id="p-minry" type="number" min="0" max="6" step="1" value="${
              params.minRy
            }"></div>
            <div class="row"><label>Flash opacity</label><input id="p-fop" type="number" min="0" max="1" step="0.05" value="${
              params.flashOpacity
            }"></div>
            <div class="row"><label>Glow opacity</label><input id="p-gop" type="number" min="0" max="1" step="0.05" value="${
              params.glowOpacity
            }"></div>
            <div class="row"><label>Easing</label>
              <select id="p-ease" style="width:100%;padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.18);background:rgba(255,255,255,0.06);color:#fff;">
                <option value="easeOutCubic" ${
                  params.easing === 'easeOutCubic' ? 'selected' : ''
                }>easeOutCubic</option>
                <option value="easeInOutCubic" ${
                  params.easing === 'easeInOutCubic' ? 'selected' : ''
                }>easeInOutCubic</option>
                <option value="easeOutQuad" ${
                  params.easing === 'easeOutQuad' ? 'selected' : ''
                }>easeOutQuad</option>
                <option value="easeInOutQuad" ${
                  params.easing === 'easeInOutQuad' ? 'selected' : ''
                }>easeInOutQuad</option>
                <option value="linear" ${
                  params.easing === 'linear' ? 'selected' : ''
                }>linear</option>
                <option value="custom" ${
                  params.easing === 'custom' ? 'selected' : ''
                }>custom (intensity)</option>
              </select>
            </div>
            <div class="row"><label>Ease intensity</label><input id="p-easeint" type="number" min="0" max="1" step="0.05" value="${
              params.easeIntensity
            }"></div>
            <div class="actions">
              <button id="p-replay" type="button">Replay</button>
              <button id="p-save" type="button">Save</button>
            </div>
            <details><summary>Note</summary><div>Overlay blocks content until fade-out. Values persist in localStorage.</div></details>
          `
          document.body.appendChild(panel)

          function readUi() {
            return {
              dotDuration: clamp(
                parseInt(document.getElementById('p-dot').value, 10) ||
                  DEFAULT_PARAMS.dotDuration,
                10,
                2000
              ),
              squishDuration: clamp(
                parseInt(document.getElementById('p-squish').value, 10) ||
                  DEFAULT_PARAMS.squishDuration,
                10,
                2000
              ),
              horizontalDuration: clamp(
                parseInt(document.getElementById('p-horiz').value, 10) ||
                  DEFAULT_PARAMS.horizontalDuration,
                10,
                4000
              ),
              verticalDuration: clamp(
                parseInt(document.getElementById('p-vert').value, 10) ||
                  DEFAULT_PARAMS.verticalDuration,
                10,
                4000
              ),
              lineHoldDuration: clamp(
                parseInt(document.getElementById('p-hold').value, 10) ||
                  DEFAULT_PARAMS.lineHoldDuration,
                0,
                1500
              ),
              anticipationStretchPx: clamp(
                parseInt(document.getElementById('p-antpx').value, 10) ||
                  DEFAULT_PARAMS.anticipationStretchPx,
                0,
                200
              ),
              anticipationDuration: clamp(
                parseInt(document.getElementById('p-antms').value, 10) ||
                  DEFAULT_PARAMS.anticipationDuration,
                0,
                2000
              ),
              anticipationRecoilDuration: clamp(
                parseInt(document.getElementById('p-recoilms').value, 10) ||
                  DEFAULT_PARAMS.anticipationRecoilDuration,
                0,
                2000
              ),
              finalPaddingPx: clamp(
                parseInt(document.getElementById('p-pad').value, 10) ||
                  DEFAULT_PARAMS.finalPaddingPx,
                0,
                1000
              ),
              glowStrength: clamp(
                parseFloat(document.getElementById('p-glow').value) ||
                  DEFAULT_PARAMS.glowStrength,
                0,
                3
              ),
              minRy: clamp(
                parseInt(document.getElementById('p-minry').value, 10) ||
                  DEFAULT_PARAMS.minRy,
                0,
                24
              ),
              flashOpacity: clamp(
                parseFloat(document.getElementById('p-fop').value) ||
                  DEFAULT_PARAMS.flashOpacity,
                0,
                1
              ),
              glowOpacity: clamp(
                parseFloat(document.getElementById('p-gop').value) ||
                  DEFAULT_PARAMS.glowOpacity,
                0,
                1
              ),
              easing:
                document.getElementById('p-ease').value ||
                DEFAULT_PARAMS.easing,
              easeIntensity: clamp(
                parseFloat(document.getElementById('p-easeint').value) ||
                  DEFAULT_PARAMS.easeIntensity,
                0,
                1
              ),
            }
          }

          document
            .getElementById('p-save')
            .addEventListener('click', function () {
              const p = readUi()
              saveParams(p)
            })

          document
            .getElementById('p-replay')
            .addEventListener('click', function () {
              const p = readUi()
              saveParams(p)
              replayWith(p)
            })

          return params
        }

        function resetOverlayState() {
          const overlay = document.getElementById('crt-overlay')
          const maskEllipse = document.getElementById('mask-ellipse')
          overlay.style.opacity = '1'
          overlay.style.pointerEvents = 'auto'
          document.body.style.overflow = 'hidden'
          maskEllipse.setAttribute('rx', '2')
          maskEllipse.setAttribute('ry', '2')
        }

        function computeTimelineEasing(params) {
          const preset = params.easing || DEFAULT_PARAMS.easing
          if (preset !== 'custom') return preset
          // Build a cubic-bezier between mild inOut and strong inOut based on intensity
          const t = clamp(
            params.easeIntensity ?? DEFAULT_PARAMS.easeIntensity,
            0,
            1
          )
          const mild = [0.455, 0.03, 0.515, 0.955] // approx easeInOutQuad
          const strong = [0.65, 0.0, 0.35, 1.0]
          const x1 = mild[0] + (strong[0] - mild[0]) * t
          const y1 = mild[1] + (strong[1] - mild[1]) * t
          const x2 = mild[2] + (strong[2] - mild[2]) * t
          const y2 = mild[3] + (strong[3] - mild[3]) * t
          return `cubicBezier(${x1.toFixed(3)}, ${y1.toFixed(3)}, ${x2.toFixed(
            3
          )}, ${y2.toFixed(3)})`
        }

        function applyVisualParams(params) {
          // Glow blur strength
          const blur1 = document.querySelector(
            '#crtGlow feGaussianBlur[result="blur1"]'
          )
          const blur2 = document.querySelector(
            '#crtGlow feGaussianBlur[result="blur2"]'
          )
          const s = Math.max(
            0,
            params.glowStrength || DEFAULT_PARAMS.glowStrength
          )
          if (blur1) blur1.setAttribute('stdDeviation', String(12 * s))
          if (blur2) blur2.setAttribute('stdDeviation', String(24 * s))

          // Opacity controls
          const flashWhite = document.getElementById('flash-white')
          const flashGlow = document.getElementById('flash-glow')
          if (flashWhite)
            flashWhite.setAttribute(
              'opacity',
              String(
                clamp(params.flashOpacity ?? DEFAULT_PARAMS.flashOpacity, 0, 1)
              )
            )
          if (flashGlow)
            flashGlow.setAttribute(
              'opacity',
              String(
                clamp(params.glowOpacity ?? DEFAULT_PARAMS.glowOpacity, 0, 1)
              )
            )
        }

        function runAnimation(pOverride) {
          const params = pOverride || readParams()
          const reduce =
            window.matchMedia &&
            window.matchMedia('(prefers-reduced-motion: reduce)').matches
          const overlay = document.getElementById('crt-overlay')
          const svg = document.getElementById('crt-svg')
          const maskEllipse = document.getElementById('mask-ellipse')

          const dims = setupSvgSizing()
          const cx = Math.round(dims.vw / 2)
          const cy = Math.round(dims.vh / 2)
          const maxRx = Math.round(
            dims.vw / 2 +
              (params.finalPaddingPx || DEFAULT_PARAMS.finalPaddingPx)
          )
          const maxRy = Math.round(
            dims.vh / 2 +
              (params.finalPaddingPx || DEFAULT_PARAMS.finalPaddingPx)
          )

          maskEllipse.setAttribute('cx', String(cx))
          maskEllipse.setAttribute('cy', String(cy))
          maskEllipse.setAttribute('rx', '2')
          maskEllipse.setAttribute('ry', '2')

          applyVisualParams(params)

          if (reduce || !window.anime) {
            // Fallback: no motion, quick fade of overlay
            maskEllipse.setAttribute('rx', String(maxRx))
            maskEllipse.setAttribute('ry', String(maxRy))
            overlay.style.transition = 'opacity 200ms ease-out'
            overlay.style.opacity = '0'
            setTimeout(() => {
              overlay.style.pointerEvents = 'none'
              document.body.style.overflow = 'auto'
            }, 220)
            return
          }

          if (window._crtTl) {
            try {
              window._crtTl.pause()
            } catch (e) {}
          }

          const tl = window.anime.timeline({
            autoplay: true,
            easing: computeTimelineEasing(params),
          })
          window._crtTl = tl

          // 1) Dot appears and tightens slightly
          tl.add({
            targets: maskEllipse,
            rx: [2, 8],
            ry: [2, 8],
            duration: params.dotDuration || DEFAULT_PARAMS.dotDuration,
          })
            // 2) Squish vertically into a thin line; start brightening the logo copy
            .add({
              targets: maskEllipse,
              ry: params.minRy || DEFAULT_PARAMS.minRy,
              duration: params.squishDuration || DEFAULT_PARAMS.squishDuration,
            })
            // 2b) Contiguous horizontal rx keyframes to avoid pauses
            .add(
              (function () {
                const frames = []
                const hold = Math.max(
                  0,
                  params.lineHoldDuration || DEFAULT_PARAMS.lineHoldDuration
                )
                const antPx = Math.max(
                  0,
                  params.anticipationStretchPx ||
                    DEFAULT_PARAMS.anticipationStretchPx
                )
                const antMs = Math.max(
                  0,
                  params.anticipationDuration ||
                    DEFAULT_PARAMS.anticipationDuration
                )
                const recMs = Math.max(
                  0,
                  params.anticipationRecoilDuration ||
                    DEFAULT_PARAMS.anticipationRecoilDuration
                )
                if (hold > 0) frames.push({ value: '+=0', duration: hold })
                if (antPx > 0 && antMs > 0)
                  frames.push({ value: `+=${antPx}`, duration: antMs })
                if (antPx > 0 && recMs > 0)
                  frames.push({ value: `-=${antPx}`, duration: recMs })
                frames.push({
                  value: maxRx,
                  duration:
                    params.horizontalDuration ||
                    DEFAULT_PARAMS.horizontalDuration,
                })
                return { targets: maskEllipse, rx: frames }
              })()
            )
            // Direct vertical after rx: seamless handoff
            .add({
              targets: maskEllipse,
              ry: maxRy,
              duration:
                params.verticalDuration || DEFAULT_PARAMS.verticalDuration,
            })
            // Final overlay fade
            .add({
              targets: overlay,
              opacity: [1, 0],
              duration: 420,
              complete: function () {
                overlay.style.pointerEvents = 'none'
                document.body.style.overflow = 'auto'
              },
            })

          // Keep the logo copy aligned during the first few frames/resizes
          function alignOnce() {
            const { vw, vh } = setupSvgSizing()
            maskEllipse.setAttribute('rx', String(maxRx))
            maskEllipse.setAttribute('ry', String(maxRy))
          }
          alignOnce()
          window.addEventListener('resize', alignOnce, { passive: true })
        }

        function replayWith(params) {
          // Reset the overlay SVG state and rerun
          resetOverlayState()
          // Small delay to ensure style/layout settles
          setTimeout(() => runAnimation(params), 20)
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', function () {
            const params = readParams()
            ensureUi(params)
            runAnimation(params)
          })
        } else {
          const params = readParams()
          ensureUi(params)
          runAnimation(params)
        }
      })()
    </script>
  </body>
</html>
